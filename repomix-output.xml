This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
components/
  Button.tsx
  Input.tsx
  TextArea.tsx
lib/
  firebase.ts
  mockData.ts
  thingsService.ts
src/
  app/
    add-thing/
      page.tsx
    context/
      AuthContext.tsx
    done/
      {thingId}/
        page.tsx
      page.tsx
    signin/
      page.tsx
    things/
      [thingId]/
        page.tsx
    globals.css
    layout.tsx
    not-found.tsx
    page.tsx
styles/
  color.ts
.gitignore
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/Button.tsx">
// src/components/Button.tsx
import React from 'react';
import { colors } from '../styles/color';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost'; // Added 'ghost' variant
}

const Button: React.FC<ButtonProps> = ({ children, variant = 'primary', className = '', ...props }) => {
  const baseStyle = 'px-4 py-2 rounded-md font-semibold focus:outline-none focus:ring-2 focus:ring-opacity-75 transition-colors duration-200';
  const variantStyles = {
    primary: `bg-[${colors.primaryAccent}] text-white hover:bg-[#6a2526] focus:ring-[${colors.primaryAccent}]`, // Using dynamic Tailwind syntax
    secondary: `bg-[${colors.doneTab}] text-white hover:bg-[#8e9caf] focus:ring-[${colors.doneTab}]`, // Using dynamic Tailwind syntax
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500', // Kept generic red for danger
    ghost: 'bg-transparent text-gray-700 hover:bg-gray-100 focus:ring-gray-300', // New ghost variant
  };

  return (
    <button
      className={`${baseStyle} ${variantStyles[variant]} ${className}`}
      {...props}
    >
      {children}
    </button>
  );
};

export default Button;
</file>

<file path="components/Input.tsx">
import React from 'react';

interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
  id: string;
}

const Input: React.FC<InputProps> = ({ label, id, className = '', ...props }) => {
  return (
    <div className="mb-4">
      {label && (
        <label htmlFor={id} className="block text-sm font-medium text-gray-700 mb-1">
          {label}
        </label>
      )}
      <input
        id={id}
        className={`block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm ${className}`}
        {...props}
      />
    </div>
  );
};

export default Input;
</file>

<file path="components/TextArea.tsx">
import React from 'react';

interface TextAreaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  label?: string;
  id: string;
}

const TextArea: React.FC<TextAreaProps> = ({ label, id, className = '', ...props }) => {
  return (
    <div className="mb-4">
      {label && (
        <label htmlFor={id} className="block text-sm font-medium text-gray-700 mb-1">
          {label}
        </label>
      )}
      <textarea
        id={id}
        rows={3}
        className={`block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm ${className}`}
        {...props}
      />
    </div>
  );
};

export default TextArea;
</file>

<file path="lib/firebase.ts">
// lib/firebase.ts
import { initializeApp, getApps, getApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Initialize Firebase
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

export { app, auth, db, storage };
</file>

<file path="lib/mockData.ts">
// src/lib/mockData.ts

export interface Thing {
  id: string;
  title: string;
  notes?: string;
  status: 'planned' | 'done';
  createdAt: string;
  doneAt?: string;
  photoUrl?: string;
}

export const mockThings: Thing[] = [
  {
    id: '1',
    title: 'Plan a weekend getaway',
    notes: 'Research cabins near the mountains or beach.',
    status: 'planned',
    createdAt: '2023-10-26T10:00:00Z',
  },
  {
    id: '2',
    title: 'Try that new restaurant',
    notes: 'The one with the great reviews for Italian food.',
    status: 'planned',
    createdAt: '2023-10-25T14:30:00Z',
  },
  {
    id: '3',
    title: 'Movie night: Oppenheimer + homemade popcorn',
    status: 'planned',
    createdAt: '2023-10-24T18:00:00Z',
  },
  {
    id: '4',
    title: 'Stargazing date',
    notes: 'Pack a blanket and hot cocoa.',
    status: 'done',
    createdAt: '2023-10-20T20:00:00Z',
    doneAt: '2023-10-21T22:30:00Z',
    photoUrl: 'https://via.placeholder.com/400x300/4CAF50/FFFFFF?text=Stargazing',
  },
  {
    id: '5',
    title: 'Hiking adventure',
    notes: 'Found a beautiful trail with a waterfall!',
    status: 'done',
    createdAt: '2023-10-15T09:00:00Z',
    doneAt: '2023-10-15T15:00:00Z',
    photoUrl: 'https://via.placeholder.com/400x300/2196F3/FFFFFF?text=Hiking',
  },
];

export const getThingById = (id: string): Thing | undefined => {
  return mockThings.find(thing => thing.id === id);
};
</file>

<file path="lib/thingsService.ts">
import { db } from './firebase';
import {
  collection,
  addDoc,
  query,
  where,
  orderBy,
  getDocs,
  doc,
  updateDoc,
  getDoc,
  serverTimestamp,
  setDoc, // Import setDoc for creating/updating user profiles
  QueryDocumentSnapshot,
  DocumentData,
} from 'firebase/firestore';

// Define the interface for a Thing document (updated addedBy to string, expecting display name)
export interface Thing {
  id: string; // This will be the Firestore doc.id
  title: string;
  notes?: string;
  status: 'planned' | 'done';
  createdAt: Date; // Stored as Timestamp in Firestore, converted to Date in client
  doneAt?: Date; // Stored as Timestamp in Firestore, converted to Date in client
  photoUrl?: string;
  addedBy: string; // Now storing displayName, not UID
}

// Define the interface for a User Profile document
export interface UserProfile {
  uid: string;
  email: string;
  displayName: string;
  partnerName: string;
  createdAt: Date;
}

// Helper to convert Firestore document to our Thing interface
const formatThingDocument = (doc: QueryDocumentSnapshot<DocumentData>): Thing => {
  const data = doc.data();
  return {
    id: doc.id,
    title: data.title,
    notes: data.notes,
    status: data.status,
    createdAt: data.createdAt ? data.createdAt.toDate() : new Date(),
    doneAt: data.doneAt ? data.doneAt.toDate() : undefined,
    photoUrl: data.photoUrl,
    addedBy: data.addedBy, // This will now be displayName
  };
};

// Helper to convert Firestore document to our UserProfile interface
const formatUserProfileDocument = (doc: QueryDocumentSnapshot<DocumentData>): UserProfile => {
  const data = doc.data();
  return {
    uid: doc.id,
    email: data.email,
    displayName: data.displayName,
    partnerName: data.partnerName,
    createdAt: data.createdAt ? data.createdAt.toDate() : new Date(),
  };
};

// --- CRUD Operations for 'things' Collection (updated addedBy param) ---

/**
 * Adds a new 'thing' to the Firestore database.
 * @param title The title of the thing.
 * @param addedByDisplayName The displayName of the user adding the thing.
 * @param notes Optional notes for the thing.
 * @returns The ID of the newly created document.
 */
export const addThing = async (title: string, addedByDisplayName: string, notes?: string): Promise<string> => {
  if (!addedByDisplayName) throw new Error('User display name is required to add a thing.');

  const docRef = await addDoc(collection(db, 'things'), {
    title,
    notes: notes || null,
    status: 'planned',
    createdAt: serverTimestamp(),
    addedBy: addedByDisplayName, // Store display name here
  });
  return docRef.id;
};

// ... (getPlannedThings, getDoneThings, getThingById, markThingAsDone, updateThingNotes, deleteThing remain the same) ...
// Ensure you update the existing getThingById function type to match the new Thing interface as well

// Just ensuring the existing functions use the correct Thing interface
export const getPlannedThings = async (): Promise<Thing[]> => {
  const q = query(
    collection(db, 'things'),
    where('status', '==', 'planned'),
    //orderBy('createdAt', 'desc')
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(formatThingDocument);
};

export const getDoneThings = async (): Promise<Thing[]> => {
  const q = query(
    collection(db, 'things'),
    where('status', '==', 'done'),
    orderBy('doneAt', 'desc')
  );
  const querySnapshot = await getDocs(q);
  return querySnapshot.docs.map(formatThingDocument);
};

export const getThingById = async (thingId: string): Promise<Thing | undefined> => {
  const docRef = doc(db, 'things', thingId);
  const docSnap = await getDoc(docRef);

  if (docSnap.exists()) {
    return formatThingDocument(docSnap as QueryDocumentSnapshot<DocumentData>);
  } else {
    return undefined;
  }
};

export const markThingAsDone = async (thingId: string, photoUrl?: string): Promise<void> => {
  const thingRef = doc(db, 'things', thingId);
  await updateDoc(thingRef, {
    status: 'done',
    doneAt: serverTimestamp(),
    ...(photoUrl && { photoUrl }),
  });
};

// --- CRUD Operations for 'users' Collection ---

/**
 * Fetches a user's profile by their UID.
 * @param uid The UID of the user.
 * @returns The UserProfile object or undefined if not found.
 */
export const getUserProfile = async (uid: string): Promise<UserProfile | undefined> => {
  const userRef = doc(db, 'users', uid);
  const docSnap = await getDoc(userRef);

  if (docSnap.exists()) {
    return formatUserProfileDocument(docSnap as QueryDocumentSnapshot<DocumentData>);
  } else {
    return undefined;
  }
};

/**
 * Creates or updates a user's profile.
 * Use this carefully, typically only during initial setup or a specific onboarding flow.
 * For this two-person app, you might only create them manually in the Firebase Console.
 * @param uid The UID of the user.
 * @param email The user's email.
 * @param displayName The user's preferred name.
 * @param partnerName The name of their partner.
 * @returns The created/updated UserProfile object.
 */
export const createOrUpdateUserProfile = async (
  uid: string,
  email: string,
  displayName: string,
  partnerName: string
): Promise<UserProfile> => {
  const userRef = doc(db, 'users', uid);
  const userProfileData = {
    uid, // Redundant but explicit for clarity
    email,
    displayName,
    partnerName,
    createdAt: serverTimestamp(), // Only set on initial creation for consistent timestamp
  };

  // setDoc with { merge: true } would update existing fields without overwriting the whole doc.
  // For initial creation, a simple setDoc is fine.
  await setDoc(userRef, userProfileData, { merge: true }); // Use merge: true to avoid overwriting createdAt if it exists

  // Refetch to get the actual serverTimestamp if it was just set
  const updatedDocSnap = await getDoc(userRef);
  if (updatedDocSnap.exists()) {
    return formatUserProfileDocument(updatedDocSnap as QueryDocumentSnapshot<DocumentData>);
  } else {
    // This case should ideally not happen after a setDoc
    throw new Error('Failed to retrieve user profile after creation/update.');
  }
};
</file>

<file path="src/app/add-thing/page.tsx">
// src/app/add-thing/page.tsx
'use client';

import React, { useState } from 'react';
import Button from '../../../components/Button';
import Input from '../../../components/Input';
import { useRouter } from 'next/navigation';
import { colors } from '../../../styles/color';
import { addThing } from '../../../lib/thingsService';
import { useAuth } from '../context/AuthContext'; // Import useAuth to get the current user

export default function AddThingPage() {
  const [title, setTitle] = useState('');
  const [notes, setNotes] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const router = useRouter();
  const { user, loading, userProfile, partnerName } = useAuth(); // Get user, loading, userProfile, and partnerName from AuthContext

  const currentPartnerName = partnerName; // Use the partnerName from AuthContext

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!title.trim()) {
      alert('You need to type something!');
      return;
    }
    if (loading || !user || !userProfile) { // Also check for userProfile now
      alert('You must be logged in and your profile loaded to add a thing.');
      return;
    }

    setIsSubmitting(true);
    try {
      // Pass userProfile.displayName for the addedBy field
      const newThingId = await addThing(title.trim(), userProfile.displayName, notes.trim() || undefined);
      console.log('Adding new thing:', { title, notes, newThingId });
      alert('Thing Added!');
      router.push('/'); // Navigate back to planned list
    } catch (error) {
      console.error('Error adding thing:', error);
      alert('Failed to add thing. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-end justify-center p-4"
      style={{ backgroundColor: 'rgba(0,0,0,0.6)' }}
    >
      <div
        className="relative w-full max-w-lg p-6 pb-8 rounded-t-3xl shadow-lg transform transition-all duration-300 ease-out translate-y-0"
        style={{
          backgroundColor: colors.background,
        }}
      >
        {/* Close Button (X) */}
        <button
          onClick={() => router.back()}
          className="absolute top-4 right-4 text-2xl font-light leading-none"
          style={{ color: colors.subheadingText }}
          aria-label="Close"
        >
          &times;
        </button>

        <h2
          className="text-3xl font-bold mb-8 text-center"
          style={{ color: colors.headingText }}
        >
          What's something you'd<br/>like to do with {currentPartnerName}
        </h2>

        <form onSubmit={handleSubmit}>
          {/* Custom Input Styling for Title */}
          <Input
            id="title"
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
            className="w-full text-center text-xl py-3 px-4 rounded-full shadow-inner focus:ring-2 focus:ring-blue-300 focus:border-blue-300 mb-4"
            style={{
              backgroundColor: colors.cardBackground,
              color: colors.headingText,
              border: 'none',
            }}
            placeholder="passear o sushi"
            disabled={isSubmitting}
          />

          {/* New TextArea for Notes */}
          <textarea
            id="notes"
            rows={3}
            value={notes}
            onChange={(e) => setNotes(e.target.value)}
            className="block w-full px-4 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-blue-300 focus:border-blue-300 sm:text-lg"
            style={{
              backgroundColor: colors.cardBackground,
              color: colors.headingText,
              borderColor: colors.borderGray,
              resize: 'none',
            }}
            placeholder="Add some notes (optional)"
            disabled={isSubmitting}
          />

          {/* Add Thing Button */}
          <Button
            type="submit"
            className="w-full mt-8 py-3 rounded-full text-xl"
            style={{
              backgroundColor: '#EB5B46',
              color: 'white',
              boxShadow: '0 4px 6px rgba(0,0,0,0.1)'
            }}
            disabled={isSubmitting || !userProfile} // Disable if profile not loaded
          >
            {isSubmitting ? 'Adding...' : 'Add Thing'}
          </Button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="src/app/context/AuthContext.tsx">
// src/app/context/AuthContext.tsx
'use client';

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  ReactNode
} from 'react';
import {
  auth
} from '../../../lib/firebase';
import {
  User,
  onAuthStateChanged
} from 'firebase/auth';
import { getUserProfile, UserProfile } from '../../../lib/thingsService';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  userProfile: UserProfile | null; // Added userProfile to the context type
  partnerName: string; // Added for easy access in UI
}

// Default partner name if userProfile isn't loaded yet, or for general display
const DEFAULT_PARTNER_NAME = "Partner";

const AuthContext = createContext < AuthContextType | undefined > (undefined);

export function AuthProvider({
  children
}: {
  children: ReactNode
}) {
  const [user, setUser] = useState < User | null > (null);
  const [userProfile, setUserProfile] = useState < UserProfile | null > (null); // New state for user profile
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (currentUser) => {
      setUser(currentUser);
      if (currentUser) {
        // If a user is logged in, fetch their profile
        try {
          const profile = await getUserProfile(currentUser.uid);
          setUserProfile(profile || null); // Set profile, or null if not found
          // TODO: Implement logic to create user profile if not found,
          // OR ensure profiles are manually pre-created in Firebase Console.
          // For now, if profile is null, displayName/partnerName will be empty/default.
        } catch (error) {
          console.error("Error fetching user profile:", error);
          setUserProfile(null);
        }
      } else {
        // If no user, clear the profile
        setUserProfile(null);
      }
      setLoading(false);
    });

    return () => unsubscribe();
  }, []);

  // Determine partnerName based on loaded userProfile
  const currentPartnerName = userProfile?.partnerName || DEFAULT_PARTNER_NAME;


  return (
    <AuthContext.Provider value={{ user, loading, userProfile, partnerName: currentPartnerName }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
</file>

<file path="src/app/done/{thingId}/page.tsx">
// src/app/done/[thingId]/page.tsx
import { getThingById, Thing } from '../../../../lib/mockData';
import { notFound } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import Button from '../../../../components/Button';
import { colors } from '../../../../styles/color';

interface DoneDetailsPageProps {
  params: { thingId: string };
}

export default function DoneDetailsPage({ params }: DoneDetailsPageProps) {
  const { thingId } = params;
  const thing: Thing | undefined = getThingById(thingId);

  if (!thing || thing.status === 'planned') {
    notFound();
  }

  return (
    <div 
      className="max-w-2xl mx-auto p-6 shadow-md rounded-lg"
      style={{ backgroundColor: colors.cardBackground }} // Card background
    >
      <h2 className="text-3xl font-bold mb-4" style={{ color: colors.headingText }}>{thing.title}</h2>

      <div className="relative w-full h-80 mb-6 bg-gray-100 rounded-md overflow-hidden">
        <Image
          src={thing.photoUrl || 'https://via.placeholder.com/800x600/CCCCCC/FFFFFF?text=No+Photo'}
          alt={thing.title}
          fill
          style={{ objectFit: 'cover' }}
          sizes="100vw"
          priority
        />
      </div>

      {thing.notes && (
        <p className="mb-4 whitespace-pre-wrap" style={{ color: colors.subheadingText }}>{thing.notes}</p>
      )}

      <p className="text-sm mb-2" style={{ color: colors.subheadingText }}>
        Added on: {new Date(thing.createdAt).toLocaleDateString()}
      </p>
      <p className="text-sm mb-6" style={{ color: colors.subheadingText }}>
        Done on: {thing.doneAt ? new Date(thing.doneAt).toLocaleDateString() : 'N/A'}
      </p>

      <Link href="/done" passHref>
        <Button variant="ghost" className="w-full"> {/* Changed to ghost */}
          Back to Memories
        </Button>
      </Link>
    </div>
  );
}
</file>

<file path="src/app/done/page.tsx">
// src/app/done/page.tsx
'use client'; 

import Link from 'next/link';
import { mockThings } from '../../../lib/mockData';
import Image from 'next/image';
import { colors } from '../../../styles/color';
import { useRouter } from 'next/navigation';

export default function DonePage() {
  const doneThings = mockThings.filter(thing => thing.status === 'done')
                               .sort((a, b) => new Date(b.doneAt!).getTime() - new Date(a.doneAt!).getTime());
  const router = useRouter();

  return (
    <div className="relative pb-20">
      {/* Custom Header - Replicated from HomePage */}
      <header 
        className="flex justify-between items-center px-6 pt-6 pb-4" 
        style={{ backgroundColor: colors.background }}
      >
        <div 
          className="flex rounded-md p-1" 
          style={{ backgroundColor: colors.borderGray }}
        >
          <Link href="/" passHref>
            <span 
              className="px-4 py-1 rounded-md text-sm font-semibold cursor-pointer" 
              style={{ backgroundColor: 'transparent', color: colors.subheadingText }}
            >
              to-do
            </span>
          </Link>
          <Link href="/done" passHref>
            <span 
              className="px-4 py-1 rounded-md text-sm font-semibold cursor-pointer" 
              style={{ backgroundColor: colors.cardBackground, color: colors.headingText }}
            >
              done
            </span>
          </Link>
        </div>

        <Link href="/add-thing" passHref>
          <span 
            className="text-2xl font-semibold cursor-pointer" 
            style={{ color: colors.primaryAccent }}
          >
            +
          </span>
        </Link>
      </header>

      <div className="max-w-4xl mx-auto px-4 mt-8">
        <h2 className="text-3xl font-bold mb-6 text-center" style={{ color: colors.headingText }}>
          Our Memories
        </h2>

        {doneThings.length === 0 ? (
          <div className="text-center py-8" style={{ color: colors.subheadingText }}>
            <p>No memories yet! Go mark some things as done.</p>
            <button 
              onClick={() => router.push('/')}
              className="mt-4 px-6 py-3 rounded-full text-lg font-semibold"
              style={{ 
                backgroundColor: '#EB5B46',
                color: 'white', 
                boxShadow: '0 4px 6px rgba(0,0,0,0.1)'
              }}
            >
              Back to Planned Things
            </button>
          </div>
        ) : (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6">
            {doneThings.map((thing) => (
              <Link href={`/done/${thing.id}`} key={thing.id} passHref>
                <div 
                  className="block cursor-pointer rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow duration-200"
                  style={{ backgroundColor: colors.cardBackground }}
                >
                  <div className="w-full h-48 relative">
                    <Image
                      src={thing.photoUrl || 'https://via.placeholder.com/400x300/CCCCCC/FFFFFF?text=No+Photo'}
                      alt={thing.title}
                      fill
                      style={{ objectFit: 'cover' }}
                      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                    />
                  </div>
                  <div className="p-4">
                    <h3 className="text-xl font-semibold" style={{ color: colors.headingText }}>{thing.title}</h3>
                    <p className="text-sm mt-2" style={{ color: colors.subheadingText }}>
                      Done on: {thing.doneAt ? new Date(thing.doneAt).toLocaleDateString() : 'N/A'}
                    </p>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/signin/page.tsx">
// src/app/signin/page.tsx
'use client';

import React, { useState, useEffect } from 'react';
import Button from '../../../components/Button';
import Input from '../../../components/Input';
import Link from 'next/link';
import { colors } from '../../../styles/color';
import { auth } from '../../../lib/firebase'; // Import auth from your firebase.ts
import { signInWithEmailAndPassword, signOut, onAuthStateChanged, User } from 'firebase/auth'; // Import Firebase auth functions
import { useRouter } from 'next/navigation';

export default function SignInPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [user, setUser] = useState<User | null>(null); // To store the authenticated user
  const [loading, setLoading] = useState(true); // Loading state for auth check
  const [error, setError] = useState<string | null>(null); // State for displaying errors
  const router = useRouter();

  useEffect(() => {
    // Listen for authentication state changes
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
      setLoading(false);
      // If a user is logged in and tries to access /signin, redirect them to home
      if (currentUser) {
        router.push('/');
      }
    });
    return () => unsubscribe(); // Cleanup subscription
  }, [router]); // Add router to dependency array to avoid lint warnings

  const handleSignIn = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null); // Clear previous errors
    if (!email.trim() || !password.trim()) {
      setError('Please enter both email and password.');
      return;
    }
    try {
      await signInWithEmailAndPassword(auth, email, password);
      // The onAuthStateChanged listener will handle the redirect to '/'
    } catch (firebaseError: any) {
      console.error('Error signing in:', firebaseError.message);
      let errorMessage = 'Sign In Failed. Please check your credentials.';
      // Provide more specific feedback for common errors
      if (firebaseError.code === 'auth/invalid-email') {
        errorMessage = 'Invalid email address format.';
      } else if (firebaseError.code === 'auth/user-not-found' || firebaseError.code === 'auth/wrong-password') {
        errorMessage = 'Invalid email or password.';
      } else if (firebaseError.code === 'auth/too-many-requests') {
        errorMessage = 'Too many failed login attempts. Please try again later.';
      }
      setError(errorMessage);
    }
  };

  const handleSignOut = async () => {
    setError(null); // Clear previous errors
    try {
      await signOut(auth);
      // The onAuthStateChanged listener will update the user state and implicitly show the sign-in form
    } catch (firebaseError: any) {
      console.error('Error signing out:', firebaseError.message);
      setError(`Sign Out Failed: ${firebaseError.message}`);
    }
  };

  if (loading) {
    return (
      <div
        className="max-w-md mx-auto p-6 text-center mt-10"
        style={{ color: colors.subheadingText }}
      >
        Loading authentication state...
      </div>
    );
  }

  // If user is logged in, we are redirecting in useEffect.
  // This component should primarily display the sign-in form.
  // We can show a simple message if somehow they stay on this page after login.
  if (user) {
    return null; // or a loading spinner, as the redirect should happen instantly
  }


  return (
    <div
      className="max-w-md mx-auto p-6 shadow-md rounded-lg mt-10"
      style={{ backgroundColor: colors.cardBackground }}
    >
      <h2 className="text-2xl font-bold mb-6 text-center" style={{ color: colors.headingText }}>
        Sign In
      </h2>

      {error && (
        <p className="text-red-500 text-center mb-4">{error}</p>
      )}

      <form onSubmit={handleSignIn}>
        <Input
          id="email"
          label="Email"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
          className="mb-4"
          placeholder="your@email.com"
        />
        <Input
          id="password"
          label="Password"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
          className="mb-6"
          placeholder="password"
        />
        <Button type="submit" className="w-full mt-4">Sign In</Button>
      </form>

      {/* This section will now only be reachable if the user is somehow on /signin AND logged in.
          The useEffect handles redirecting logged-in users, so this block might rarely be seen.
          However, keeping it consistent with the previous design for context.
       */}
      {/* {user && (
        <div className="mt-8 text-center">
          <p className="mb-4" style={{ color: colors.subheadingText }}>
            You are currently signed in as {user.email}.
          </p>
          <div className="flex justify-center space-x-4">
            <Link href="/" passHref>
              <Button variant="secondary">Go to Home</Button>
            </Link>
            <Button onClick={handleSignOut} variant="danger">Sign Out</Button>
          </div>
        </div>
      )} */}
    </div>
  );
}
</file>

<file path="src/app/things/[thingId]/page.tsx">
// src/app/things/[thingId]/page.tsx
'use client'; 

import React from 'react';
import { getThingById, Thing } from '../../../../lib/mockData';
import { notFound, useRouter } from 'next/navigation';
import Button from '../../../../components/Button';
import { colors } from '../../../../styles/color';

interface ThingDetailsPageProps {
  params: { thingId: string };
}

export default function ThingDetailsPage({ params }: ThingDetailsPageProps) {
  const { thingId } = params;
  const thing: Thing | undefined = getThingById(thingId);
  const router = useRouter();

  if (!thing || thing.status === 'done') {
    notFound();
  }

  const handleMarkAsDone = () => {
    console.log(`Marking "${thing.title}" as done.`);
    alert(`"${thing.title}" marked as done! (Mock action)`);
    router.push('/done');
  };

  return (
    <div 
      className="max-w-xl mx-auto p-6 shadow-md rounded-lg"
      style={{ backgroundColor: colors.cardBackground }} // Card background
    >
      <h2 className="text-3xl font-bold mb-4" style={{ color: colors.headingText }}>{thing.title}</h2>
      {thing.notes && (
        <p className="mb-6 whitespace-pre-wrap" style={{ color: colors.subheadingText }}>{thing.notes}</p>
      )}
      <p className="text-sm mb-6" style={{ color: colors.subheadingText }}>
        Added on: {new Date(thing.createdAt).toLocaleDateString()}
      </p>

      <Button onClick={handleMarkAsDone} className="w-full">
        Mark as Done & Add Photo (Later)
      </Button>

      <Button variant="ghost" onClick={() => router.back()} className="w-full mt-4"> {/* Changed to ghost */}
        Back to Planned
      </Button>
    </div>
  );
}
</file>

<file path="src/app/not-found.tsx">
import Link from 'next/link'
import Button from '../../components/Button'

export default function NotFound() {
  return (
    <div className="flex flex-col items-center justify-center min-h-[calc(100vh-10rem)] p-4 text-center">
      <h2 className="text-4xl font-bold text-gray-800 mb-4">Not Found</h2>
      <p className="text-lg text-gray-600 mb-6">Could not find requested resource</p>
      <Link href="/" passHref>
        <Button>Return Home</Button>
      </Link>
    </div>
  )
}
</file>

<file path="styles/color.ts">
export const colors = {
  background: '#F8F3ED', 
  primaryAccent: '#7B2C2D', 
  cardBackground: '#FFFFFF', 
  headingText: '#1A1A1A', 
  subheadingText: '#333333', 
  borderGray: '#E0E0E0', 
  doneTab: '#A3B1C6', 
  heartIcon: '#E74C3C', 
};

export type ColorName = keyof typeof colors;
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  /* Define CSS variables for your colors for easier global use */
  --color-background: #F8F3ED;
  --color-primary-accent: #7B2C2D;
  --color-card-background: #FFFFFF;
  --color-heading-text: #1A1A1A;
  --color-subheading-text: #333333;
  --color-border-gray: #E0E0E0;
  --color-done-tab: #A3B1C6;
  --color-heart-icon: #E74C3C;
}

body {
  background-color: var(--color-background);
  color: var(--color-subheading-text); /* Default text color */
}

h1, h2, h3, h4, h5, h6 {
  color: var(--color-heading-text); /* Headings use darker text */
}

/* Ensure these are present from your Tailwind setup */
/* You might have more base styles depending on your create-next-app choices */
</file>

<file path="src/app/layout.tsx">
// src/app/layout.tsx
'use client';

import type { Metadata } from 'next'; // Metadata is typically server-only, but we can manage it.
// For client components, you might need to move Metadata to a `head.tsx` or use a wrapper.
// For now, we'll keep it simple for demonstration. In a real app, you might use a <title> tag directly.
import { Inter } from 'next/font/google';
import './globals.css';
import { colors } from '../../styles/color';
import { AuthProvider, useAuth } from './context/AuthContext'; // Import AuthProvider and useAuth
import { useRouter, usePathname } from 'next/navigation';
import { useEffect, ReactNode } from 'react';

const inter = Inter({ subsets: ['latin'] });

// We define Metadata separately as a constant because client components cannot export metadata directly
// In a real app, you might manage this using a dedicated head.tsx or a more advanced approach.
const appMetadata: Metadata = {
  title: 'My Couple App',
  description: 'A shared app for you and your partner.',
};


// Inner component to handle auth logic and render children
function AuthWrapper({ children }: { children: ReactNode }) {
  const { user, loading } = useAuth();
  const router = useRouter();
  const pathname = usePathname();

  useEffect(() => {
    // If not loading, no user, and not on the sign-in page, redirect to sign-in
    if (!loading && !user && pathname !== '/signin') {
      router.push('/signin');
    }
    // If loading or user exists, but on the sign-in page, redirect to home
    if ((loading || user) && pathname === '/signin') {
      router.push('/');
    }
  }, [user, loading, pathname, router]);

  // If loading, show a global loading indicator
  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-screen" style={{ backgroundColor: colors.background, color: colors.subheadingText }}>
        Loading application...
      </div>
    );
  }

  // If user is not logged in AND not on the sign-in page, we are actively redirecting, so show nothing or a redirect message.
  if (!user && pathname !== '/signin') {
    return (
      <div className="flex items-center justify-center min-h-screen" style={{ backgroundColor: colors.background, color: colors.subheadingText }}>
        Redirecting to sign-in...
      </div>
    );
  }

  // Otherwise, render the children (the actual page content)
  return <>{children}</>;
}


export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head>
        {/* Manually include title/description if `metadata` export is removed due to 'use client' */}
        <title>{appMetadata.title as string}</title>
        <meta name="description" content={appMetadata.description as string} />
      </head>
      <body className={inter.className} style={{ backgroundColor: colors.background }}>
        <AuthProvider>
          <AuthWrapper> {/* Wrap children with AuthWrapper */}
            <main className="min-h-screen">
              {children}
            </main>
            <footer
              style={{
                padding: '1rem',
                borderTop: `1px solid ${colors.borderGray}`,
                textAlign: 'center',
                fontSize: '0.8rem',
                color: colors.subheadingText,
                backgroundColor: colors.cardBackground
              }}
            >
              <p>&copy; {new Date().getFullYear()} My Couple App | Version 1.0</p>
            </footer>
          </AuthWrapper>
        </AuthProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/page.tsx">
// src/app/page.tsx
'use client';

import Link from 'next/link';
// import { mockThings } from '../../lib/mockData'; // REMOVE THIS LINE
import { colors } from '../../styles/color';
import React, { useState, useEffect } from 'react'; // Import useEffect
import { useAuth } from '../app/context/AuthContext';
import { auth } from '../../lib/firebase';
import { signOut } from 'firebase/auth';
import { getPlannedThings, getDoneThings, Thing } from '../../lib/thingsService'; // Import Firestore service functions and Thing interface

export default function HomePage() {
  const { user, loading, partnerName } = useAuth(); // Get user, loading, and partnerName from AuthContext
  const [plannedThings, setPlannedThings] = useState<Thing[]>([]); // State to store planned things
  const [doneThingsCount, setDoneThingsCount] = useState(0); // State for done things count
  const [isLoadingThings, setIsLoadingThings] = useState(true); // Loading state for fetching things
  const [error, setError] = useState<string | null>(null); // Error state

  // Fetch things from Firestore when component mounts or user/loading changes
  useEffect(() => {
    const fetchThings = async () => {
      if (!loading && user) { // Only fetch if not loading auth and user is logged in
        setIsLoadingThings(true);
        setError(null);
        try {
          const fetchedPlannedThings = await getPlannedThings();
          setPlannedThings(fetchedPlannedThings);

          const fetchedDoneThings = await getDoneThings();
          setDoneThingsCount(fetchedDoneThings.length);
        } catch (err: any) {
          console.error("Error fetching things:", err);
          setError("Failed to load things. Please try again.");
        } finally {
          setIsLoadingThings(false);
        }
      } else if (!loading && !user) {
        // If not loading and no user, clear things (redirect will handle auth)
        setPlannedThings([]);
        setDoneThingsCount(0);
        setIsLoadingThings(false);
      }
    };

    fetchThings();
  }, [loading, user]); // Re-run effect when auth state changes

  const handleSignOut = async () => {
    try {
      await signOut(auth);
    } catch (error: any) {
      console.error('Error signing out:', error.message);
      alert(`Sign Out Failed: ${error.message}`);
    }
  };

  // Display loading state
  if (isLoadingThings || loading) {
    return (
      <div className="flex items-center justify-center min-h-screen" style={{ backgroundColor: colors.background, color: colors.subheadingText }}>
        Loading your shared things...
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8" style={{ color: colors.subheadingText }}>
        <p className="text-red-500 mb-4">{error}</p>
        <button
          onClick={() => window.location.reload()} // Simple reload to retry
          className="mt-4 px-6 py-3 rounded-full text-lg font-semibold"
          style={{
            backgroundColor: colors.primaryAccent,
            color: 'white',
            boxShadow: '0 4px 6px rgba(0,0,0,0.1)'
          }}
        >
          Reload Page
        </button>
      </div>
    );
  }


  return (
    <div className="relative pb-20">
      {/* Custom Header */}
      <header
        className="flex justify-between items-center px-6 pt-6 pb-4"
        style={{ backgroundColor: colors.background }}
      >
        <div
          className="flex rounded-md p-1"
          style={{ backgroundColor: colors.borderGray }}
        >
          <Link href="/" passHref>
            <span
              className="px-4 py-1 rounded-md text-sm font-semibold cursor-pointer"
              style={{ backgroundColor: colors.cardBackground, color: colors.headingText }}
            >
              to-do
            </span>
          </Link>
          <Link href="/done" passHref>
            <span
              className="px-4 py-1 rounded-md text-sm font-semibold cursor-pointer"
              style={{ backgroundColor: 'transparent', color: colors.subheadingText }}
            >
              done
            </span>
          </Link>
        </div>

        {/* Right side of header: Add button and new Sign Out button */}
        <div className="flex items-center space-x-4">
          <Link href="/add-thing" passHref>
            <span
              className="text-2xl font-semibold cursor-pointer"
              style={{ color: colors.primaryAccent }}
            >
              +
            </span>
          </Link>
          {user && (
            <button
              onClick={handleSignOut}
              className="px-3 py-1 text-sm rounded-md font-semibold"
              style={{ backgroundColor: colors.primaryAccent, color: colors.cardBackground }}
            >
              Sign Out
            </button>
          )}
        </div>
      </header>

      <div className="max-w-xl mx-auto px-4 mt-8">
        <div
          className="p-6 rounded-2xl shadow-md mb-8"
          style={{ backgroundColor: colors.cardBackground }}
        >
          <h2 className="text-4xl font-bold mb-2" style={{ color: colors.headingText }}>
            Things with {partnerName}
          </h2>
          <div className="flex items-center text-lg" style={{ color: colors.subheadingText }}>
            <span className="mr-2">{doneThingsCount} things done</span>
            <span style={{ color: colors.heartIcon }}>❤️</span>
          </div>
        </div>

        <h3 className="text-xl font-semibold mb-4" style={{ color: colors.headingText }}>Things</h3>

        {plannedThings.length === 0 ? (
          <div className="text-center py-8" style={{ color: colors.subheadingText }}>
            <p>No planned items yet! Time to dream up some adventures.</p>
            <Link href="/add-thing" passHref>
              <button
                className="mt-4 px-6 py-3 rounded-full text-lg font-semibold"
                style={{
                  backgroundColor: '#EB5B46',
                  color: 'white',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)'
                }}
              >
                Add Your First Thing
              </button>
            </Link>
          </div>
        ) : (
          <ul className="space-y-4">
            {plannedThings.map((thing, index) => (
              <li key={thing.id} className="relative z-[1]" style={{
                marginTop: index > 0 ? '-1rem' : '0'
              }}>
                <Link href={`/things/${thing.id}`} passHref>
                  <div
                    className="block cursor-pointer p-6 rounded-xl shadow-md"
                    style={{
                      backgroundColor: colors.primaryAccent,
                      color: colors.cardBackground,
                      transform: `rotate(${index % 2 === 0 ? -1.5 : 1.5}deg)`,
                      transition: 'transform 0.2s ease-in-out',
                      zIndex: plannedThings.length - index // Ensure correct stacking order
                    }}
                  >
                    <h3 className="text-3xl font-bold">{thing.title}</h3>
                    {/* Optionally display who added it */}
                    {thing.addedBy && (
                      <p className="text-sm opacity-80 mt-2">Added by {thing.addedBy}</p>
                    )}
                  </div>
                </Link>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*
.env.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'via.placeholder.com',
        port: '',
        pathname: '/**', // Allow all paths from this hostname
      },
      // You will add your Firebase Storage hostname here later!
      // Example for Firebase Storage (adjust bucket name):
      // {
      //   protocol: 'https',
      //   hostname: 'firebasestorage.googleapis.com',
      //   port: '',
      //   pathname: '/v0/b/your-firebase-project.appspot.com/o/**',
      // },
    ],
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "fashisk_marianuxa",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start"
  },
  "dependencies": {
    "firebase": "^12.3.0",
    "next": "15.5.4",
    "react": "19.1.0",
    "react-dom": "19.1.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

</files>
